You are given an integer array nums and an integer k.
An array is considered balanced if the value of its maximum element is at most k times the minimum element.
You may remove any number of elements from nums​​​​​​​ without making it empty.
Return the minimum number of elements to remove so that the remaining array is balanced.

Note: An array of size 1 is considered balanced as its maximum and minimum are equal, and the condition always holds true.
Example 1:
Input: nums = [2,1,5], k = 2
Output: 1
Explanation:
Remove nums[2] = 5 to get nums = [2, 1].
Now max = 2, min = 1 and max <= min * k as 2 <= 1 * 2. Thus, the answer is 1.

Example 2
Input: nums = [1,6,2,9], k = 3
Output: 2
Explanation:
Remove nums[0] = 1 and nums[3] = 9 to get nums = [6, 2].
Now max = 6, min = 2 and max <= min * k as 6 <= 2 * 3. Thus, the answer is 2.

Example 3:
Input: nums = [4,6], k = 2
Output: 0
Explanation:
Since nums is already balanced as 6 <= 4 * 2, no elements need to be removed.
 
Constraints:
1 <= nums.length <= 105
1 <= nums[i] <= 109
1 <= k <= 105
 
-------------------------------------------------------------------------------------
Code
-------------------------------------------------------------------------------------
in java : Approch ->
Approach: Sorting + Two Pointers
Intuition
We first sort the array nums. After removing some elements to make the array balanced, let the minimum element in the remaining array be min and the maximum element be max. All elements strictly smaller than min and strictly larger than max must be removed. Removing any element within the range [min,max] is unnecessary.
Based on this observation, we can use a two-pointer technique. The left pointer left starts at the beginning of the sorted array and represents the position of the minimum element x of the current candidate subarray. The right pointer right moves to the right until it reaches the first element that is strictly greater than k×x, or until it goes out of bounds.
At this point, the left-closed and right-open interval [left,right) represents a balanced subarray, whose length is right−left.
As the left pointer moves to the right, the right pointer never moves backward. For each position of left, we can update the answer as n−(right−left), where n is the length of the array nums.


class Solution {
    public int minRemoval(int[] nums, int k) {
        
        int n = nums.length;
        Arrays.sort(nums);

        int ans = n;
        int right = 0;

        for(int left = 0; left < n; left++){
            while(right < n && nums[right] <= (long) nums[left] * k){
                right++;
            }
            ans = Math.min(ans, n - (right - left));
        }
        return ans;
    }
}

Complexity Analysis

Let n be the length of the array nums.
Time complexity: O(nlogn).
Sorting takes O(nlogn) time, and the two-pointer traversal takes O(n) time.
Space complexity: O(logn) or O(n).
This includes the stack space required by the sorting process, since built-in sorting implementations typically use a variant of quicksort or timsort.


